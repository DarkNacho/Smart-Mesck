{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#code-annotation-examples","title":"Code Annotation Examples","text":""},{"location":"#codeblocks","title":"Codeblocks","text":"<p>Some <code>code</code> goes here.</p>"},{"location":"#plain-codeblock","title":"Plain codeblock","text":"<p>A plain codeblock:</p> <pre><code>Some code here\ndef myfunction()\n// some comment\n</code></pre>"},{"location":"#code-for-a-specific-language","title":"Code for a specific language","text":"<p>Some more code with the <code>py</code> at the start:</p> <pre><code>import tensorflow as tf\ndef whatever()\n</code></pre>"},{"location":"#with-a-title","title":"With a title","text":"bubble_sort.py<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#with-line-numbers","title":"With line numbers","text":"<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#highlighting-lines","title":"Highlighting lines","text":"<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#icons-and-emojs","title":"Icons and Emojs","text":""},{"location":"#prueba-de-inclusion","title":"Prueba de inclusi\u00f3n","text":"<p>!include ./extra/test.md</p>"},{"location":"lab/","title":"Laboratorio de Inteligencia Artificial Aplicada (LIAA)","text":""},{"location":"lab/#home-inicio","title":"Home (Inicio)","text":""},{"location":"lab/#bienvenida","title":"Bienvenida","text":"<p>Bienvenido al Laboratorio de Inteligencia Artificial Aplicada (LIAA) de la Universidad de Talca, Facultad de Ingenier\u00eda. Nuestro objetivo es impulsar la investigaci\u00f3n y la innovaci\u00f3n en el campo de la inteligencia artificial aplicada.</p>"},{"location":"lab/#noticias","title":"Noticias","text":"<ul> <li>Noticia 1</li> <li>Noticia 2</li> <li>Noticia 3</li> </ul>"},{"location":"lab/#sobre-nosotros","title":"Sobre Nosotros","text":""},{"location":"lab/#mision-y-vision","title":"Misi\u00f3n y Visi\u00f3n","text":"<p>Nuestra misi\u00f3n es desarrollar soluciones innovadoras utilizando inteligencia artificial para resolver problemas complejos en diversas \u00e1reas. Nuestra visi\u00f3n es ser un referente en investigaci\u00f3n aplicada y formaci\u00f3n de capital humano avanzado.</p>"},{"location":"lab/#equipo","title":"Equipo","text":""},{"location":"lab/#director","title":"Director","text":"<ul> <li>Dr. C\u00e9sar Astudillo</li> </ul>"},{"location":"lab/#estudiantes-doctorales","title":"Estudiantes Doctorales","text":"<ul> <li>Dr (c) Javiera Arias</li> <li>Ing. Hugo Nu\u00f1ez</li> </ul>"},{"location":"lab/#ingeniero-de-apoyo","title":"Ingeniero de Apoyo","text":"<ul> <li>Ing. Ignacio Martinez</li> </ul>"},{"location":"lab/#estudiantes-tesistas","title":"Estudiantes Tesistas","text":"<ul> <li>Elias Ocque</li> </ul>"},{"location":"lab/#investigacion","title":"Investigaci\u00f3n","text":""},{"location":"lab/#proyectos-actuales","title":"Proyectos Actuales","text":"<ul> <li>Proyecto 1</li> <li>Proyecto 2</li> <li>Proyecto 3</li> </ul>"},{"location":"lab/#red-de-colaboracion","title":"Red de Colaboraci\u00f3n","text":"<ul> <li>David Diaz, FEN, UCHILE</li> <li>Xaviera Lopez, Facultad de Ingenier\u00eda, UCM</li> <li>Juan Bekios, UCN</li> <li>John Ommen, Carleton University, Canada</li> <li>Colin Belinger, Canada</li> <li>Alfredo Candia, UFT, Chile</li> <li>Sebastian Maldonado, FEN, Uchile</li> <li>Ruber Hern\u00e1ndez, UCM</li> <li>Sergio Elastin, Queen Mary University, UK</li> </ul>"},{"location":"lab/#publicaciones","title":"Publicaciones","text":""},{"location":"lab/#articulos-cientificos","title":"Art\u00edculos Cient\u00edficos","text":"<ul> <li>Art\u00edculo 1</li> <li>Art\u00edculo 2</li> <li>Art\u00edculo 3</li> </ul>"},{"location":"lab/#presentaciones-en-congresos","title":"Presentaciones en Congresos","text":"<ul> <li>Presentaci\u00f3n 1</li> <li>Presentaci\u00f3n 2</li> <li>Presentaci\u00f3n 3</li> </ul>"},{"location":"lab/#tesis-anteriores","title":"Tesis Anteriores","text":"<ul> <li>Tesis 1</li> <li>Tesis 2</li> <li>Tesis 3</li> </ul>"},{"location":"lab/#actividades","title":"Actividades","text":""},{"location":"lab/#eventos-cientificos","title":"Eventos Cient\u00edficos","text":"<ul> <li>ICPRS</li> <li>CIARP</li> <li>INFORNOR</li> <li>Webinar ACHIRP</li> </ul>"},{"location":"lab/#actividades-de-difusion","title":"Actividades de Difusi\u00f3n","text":"<ul> <li>Actividad 1</li> <li>Actividad 2</li> <li>Actividad 3</li> </ul>"},{"location":"lab/#contacto","title":"Contacto","text":""},{"location":"lab/#formulario-de-contacto","title":"Formulario de Contacto","text":"<p>Si tienes alguna consulta o deseas m\u00e1s informaci\u00f3n, por favor rellena el formulario de contacto.</p>"},{"location":"lab/#informacion-de-contacto","title":"Informaci\u00f3n de Contacto","text":"<ul> <li>Direcci\u00f3n: Universidad de Talca, Facultad de Ingenier\u00eda</li> <li>Tel\u00e9fono: +56 71 234 5678</li> <li>Correo Electr\u00f3nico: info@liaa.utalca.cl</li> </ul>"},{"location":"lab/#recursos","title":"Recursos","text":""},{"location":"lab/#enlaces-utiles","title":"Enlaces \u00datiles","text":"<ul> <li>Enlace 1</li> <li>Enlace 2</li> <li>Enlace 3</li> </ul>"},{"location":"lab/#descargas","title":"Descargas","text":"<ul> <li>Documento 1</li> <li>Documento 2</li> <li>Documento 3</li> </ul>"},{"location":"Desplegar/docker/","title":"Utilizando Docker","text":""},{"location":"Desplegar/docker/#despliegue-del-proyecto-con-docker-compose","title":"Despliegue del proyecto con Docker Compose","text":"<p>Docker es una plataforma de virtualizaci\u00f3n a nivel de contenedores que permite empaquetar una aplicaci\u00f3n y sus dependencias en un contenedor ligero y port\u00e1til. Un contenedor Docker incluye todo lo necesario para ejecutar la aplicaci\u00f3n de manera eficiente y consistente, como el c\u00f3digo, las bibliotecas, las herramientas y las configuraciones.</p> <p>Docker Compose, por otro lado, es una herramienta que facilita la gesti\u00f3n y la orquestaci\u00f3n de m\u00faltiples contenedores Docker. Permite definir y configurar servicios y sus dependencias en un archivo YAML, lo que simplifica el despliegue y la gesti\u00f3n de aplicaciones que se componen de varios contenedores interconectados.</p> <p>En el contexto de este proyecto, se ha utilizado Docker y Docker Compose para empaquetar y desplegar la aplicaci\u00f3n en contenedores Docker. Esto proporciona un entorno aislado y consistente para ejecutar el proyecto, independientemente de las diferencias en los entornos de desarrollo o producci\u00f3n. Al utilizar Docker Compose, se simplifica a\u00fan m\u00e1s el proceso de ejecuci\u00f3n y gesti\u00f3n de los contenedores que forman parte del proyecto.</p> <p>A continuaci\u00f3n, se presentar\u00e1n las instrucciones para desplegar el proyecto utilizando Docker y Docker Compose, lo que permitir\u00e1 ejecutar la aplicaci\u00f3n de manera r\u00e1pida y sencilla en cualquier entorno compatible con Docker.</p> <ol> <li> <p>Descargar Docker Compose    Antes de poder ejecutar un archivo <code>docker-compose.yml</code>, necesitar\u00e1s tener Docker Compose instalado en tu sistema. Sigue estos pasos para descargarlo:</p> </li> <li> <p>Visita la p\u00e1gina de  Docker Compose.</p> </li> <li>Sigue las instrucciones de instalaci\u00f3n correspondiente a tu sistema operativo (Windows, macOS o Linux).</li> <li> <p>Verifica que Node.js se haya instalado correctamente abriendo una ventana de terminal y ejecutando el siguiente comando:</p> <pre><code>$ docker compose version\nDocker Compose version v2.20.2\n</code></pre> </li> </ol> <p>Ahora deber\u00edas tener Docker Compose instalado en tu sistema. 2. Edici\u00f3n</p> <ul> <li> <p>Seleci\u00f3n de puertos</p> <p>Aqu\u00ed tienes una explicaci\u00f3n del mapeo de puertos en el archivo <code>docker-compose.yml</code> proporcionado:</p> <p><pre><code>services:\nui:\n    ports:\n    - 5001:80\napi:\n    ports:\n    - 5002:80\ngraph:\n    ports:\n    - 5003:80\n</code></pre>  En este ejemplo, hay tres servicios definidos: <code>ui</code>, <code>api</code> y <code>graph</code>.</p> <ul> <li>Para el servicio <code>ui</code>, se realiza un mapeo del puerto <code>5001</code> del host al puerto <code>80</code> del contenedor. Esto significa que puedes acceder al servicio de la interfaz de usuario (UI) desde tu m\u00e1quina local utilizando <code>http://localhost:5001</code>.</li> <li>Para el servicio <code>api</code>, se realiza un mapeo del puerto <code>5002</code> del host al puerto <code>80</code> del contenedor. Esto significa que puedes acceder al servicio de la API desde tu m\u00e1quina local utilizando <code>http://localhost:5002</code>.</li> <li>Para el servicio <code>graph</code>, se realiza un mapeo del puerto <code>5003</code> del host al puerto <code>80</code> del contenedor. Esto significa que puedes acceder al servicio de gr\u00e1ficos desde tu m\u00e1quina local utilizando <code>http://localhost:5003</code>.</li> </ul> <p>El formato del mapeo de puertos es <code>&lt;puerto_del_host&gt;:&lt;puerto_del_contenedor&gt;</code>. Esto permite redirigir las solicitudes que llegan al puerto del host especificado al puerto correspondiente dentro del contenedor.</p> <p>Es importante tener en cuenta que si los puertos especificados (<code>5001</code>, <code>5002</code>, <code>5003</code> en este caso) ya est\u00e1n en uso en tu m\u00e1quina local, deber\u00e1s elegir puertos diferentes para el mapeo o liberar los puertos en uso antes de ejecutar el archivo <code>docker-compose.yml</code>.</p> <p>El mapeo de puertos es \u00fatil para exponer los servicios de tus contenedores de Docker a trav\u00e9s de puertos accesibles en tu m\u00e1quina local, lo que te permite interactuar con ellos desde tu navegador web u otras herramientas externas.    - Asignar variables de entorno</p> <ol> <li> <p>Credenciales de la base de datos:</p> <ul> <li><code>DATABASE_Host</code>: Especifica el host o la direcci\u00f3n IP del servidor de la base de datos.</li> <li><code>DATABASE_Port</code>: Indica el puerto en el que se escucha la conexi\u00f3n de la base de datos.</li> <li><code>DATABASE_Username</code>: Representa el nombre de usuario utilizado para autenticarse en la base de datos.</li> <li><code>DATABASE_Password</code>: Es la contrase\u00f1a asociada al usuario de la base de datos.</li> <li> <p><code>DATABASE_Database</code>: Especifica el nombre de la base de datos a la que se desea conectar.</p> </li> <li> <p>Credenciales de correo electr\u00f3nico (MAIL):</p> </li> <li> <p><code>MAIL_Sender</code>: Es la direcci\u00f3n de correo electr\u00f3nico del remitente.</p> </li> <li><code>MAIL_DisplayName</code>: Es el nombre que se mostrar\u00e1 como remitente en los correos electr\u00f3nicos enviados.</li> <li><code>MAIL_Password</code>: Representa la contrase\u00f1a o clave de acceso del correo electr\u00f3nico del remitente.</li> <li><code>MAIL_SmtpHost</code>: Especifica el host del servidor SMTP utilizado para enviar correos electr\u00f3nicos.</li> <li> <p><code>MAIL_Port</code>: Indica el puerto utilizado para la conexi\u00f3n SMTP.</p> <ol> <li>Variable secreta (JWT_KEY):</li> </ol> </li> <li> <p><code>JWT_KEY</code>: Es una clave secreta utilizada para firmar y verificar los tokens de autenticaci\u00f3n JWT (JSON Web Token). Esta clave debe ser \u00fanica y mantenerse en secreto para garantizar la seguridad de los tokens generados.</p> <ol> <li>Direcciones (URL)</li> </ol> </li> <li> <p><code>UI_URL</code>: Especifica la direcci\u00f3n donde se encuentra Smart-Mesck-UI</p> </li> <li><code>API_URL</code>: Especifica la direcci\u00f3n donde se encuentra Smart-Mesck-API</li> <li><code>GRAPH_URL</code>: Especifica la direcci\u00f3n donde se encuentra Smart-Mesck-Graph</li> <li>Ejecutar Docker Compose</li> </ul> </li> </ol> </li> </ul> <p>Una vez que tengas el archivo <code>docker-compose.yml</code> listo, puedes ejecutarlo utilizando el siguiente comando:</p> <p><pre><code>$ docker-compose up\n</code></pre>    Aseg\u00farate de abrir tu terminal y ubicarte en el directorio donde se encuentra el archivo <code>docker-compose.yml</code> antes de ejecutar el comando.</p> <p>Docker Compose leer\u00e1 el archivo <code>docker-compose.yml</code>, crear\u00e1 los contenedores y configuraciones definidas en \u00e9l, y los iniciar\u00e1. Ver\u00e1s los registros de salida de cada contenedor en la terminal.</p> <p>Si deseas ejecutar Docker Compose en modo desacoplado (en segundo plano), puedes utilizar la opci\u00f3n <code>-d</code>:</p> <p><pre><code>$ docker-compose up -d\n</code></pre> 4. Detener los servicios: Para detener los servicios y los contenedores en ejecuci\u00f3n, puedes utilizar el siguiente comando:</p> <p><pre><code>docker-compose down\n</code></pre>    Esto detendr\u00e1 y eliminar\u00e1 los contenedores creados a partir del archivo <code>docker-compose.yml</code>.</p>"},{"location":"Desplegar/docker/#ejecucion-de-servicios-individuales-con-docker","title":"Ejecuci\u00f3n de servicios individuales con Docker","text":"<p>Cada servicio incluye su propio <code>Dockerfile</code>, lo que te permite ejecutarlos de forma individual si as\u00ed lo deseas. A continuaci\u00f3n, se muestra c\u00f3mo puedes hacerlo:</p> <ol> <li> <p>Edici\u00f3n de variables de entorno    Antes de construir y ejecutar los servicios individuales, debes editar las variables de entorno en los respectivos archivo de Docker. Estas variables son similares a las que se mencionaron en la secci\u00f3n anterior de Docker Compose.</p> </li> <li> <p>Abre el <code>Dockerfile</code> correspondiente al servicio que deseas ejecutar de forma individual, estos se encuentran en la carpeta de cada servicio.</p> </li> <li> <p>Busca las instrucciones <code>ENV</code> en el Dockerfile y edita los valores de las variables de entorno seg\u00fan tus necesidades.</p> </li> <li> <p>Construcci\u00f3n y ejecuci\u00f3n del servicio    Una vez que hayas editado las variables de entorno, puedes construir y ejecutar el servicio utilizando los siguientes comandos:</p> </li> <li> <p>Navega hasta el directorio que contiene el Dockerfile del servicio que deseas ejecutar.</p> </li> <li> <p>Ejecuta el siguiente comando para construir la imagen del Docker:</p> <pre><code>$ docker build -t nombre_imagen .\n</code></pre> <p>Aseg\u00farate de reemplazar <code>nombre_imagen</code> con un nombre significativo para la imagen del servicio.</p> </li> <li> <p>Despu\u00e9s de que la imagen se haya construido correctamente, puedes ejecutar el servicio utilizando el siguiente comando:</p> <pre><code>$ docker run -p puerto_host:puerto_contenedor nombre_imagen\n</code></pre> <p>Reemplaza <code>puerto_host</code> con el puerto del host en el que deseas mapear el servicio, y <code>puerto_contenedor</code> con el puerto en el que el servicio se est\u00e1 ejecutando dentro del contenedor.</p> <p>Por ejemplo, si deseas ejecutar el servicio de interfaz de usuario en el puerto 5001 de tu host, y has construido la imagen con el nombre <code>ui-image</code>, puedes ejecutar el siguiente comando:</p> <pre><code>$ docker run -p 5001:80 ui-image\n</code></pre> <p>Esto iniciar\u00e1 el contenedor del servicio de interfaz de usuario y lo mapear\u00e1 al puerto 5001 de tu m\u00e1quina local.</p> </li> <li> <p>Edici\u00f3n de variables de entorno para servicios individuales    Si deseas editar las variables de entorno para los servicios individuales, puedes hacerlo siguiendo los mismos pasos descritos anteriormente en la secci\u00f3n de Docker Compose. Busca las variables de entorno correspondientes en el Dockerfile del servicio que est\u00e1s ejecutando de forma individual y modifica sus valores seg\u00fan sea necesario.</p> </li> </ol> <p>Recuerda que al editar las variables de entorno en los Dockerfiles, debes tener en cuenta la configuraci\u00f3n espec\u00edfica de cada servicio y asegurarte de proporcionar los valores correctos para un funcionamiento adecuado.</p>"},{"location":"Desplegar/intro/","title":"Exposici\u00f3n de Servicios","text":"<p>En el contexto de la infraestructura de servidores, los servicios son funcionalidades o capacidades espec\u00edficas que un servidor proporciona a los clientes o usuarios. Estos servicios pueden variar ampliamente seg\u00fan la naturaleza del servidor y las necesidades del sistema. En este informe, se explorar\u00e1 qu\u00e9 es un servicio en el contexto de los servidores y c\u00f3mo se expone para permitir su acceso desde redes externas, como Internet.</p>"},{"location":"Desplegar/intro/#definicion-de-un-servicio-en-un-servidor","title":"Definici\u00f3n de un servicio en un servidor","text":"<p>Un servicio en un servidor se refiere a una funcionalidad espec\u00edfica que el servidor ofrece a trav\u00e9s de una interfaz de programaci\u00f3n de aplicaciones (API) definida. Puede ser un servicio web, un servicio de base de datos, un servicio de autenticaci\u00f3n, un servicio de procesamiento de im\u00e1genes, entre otros. Cada servicio tiene su propia l\u00f3gica de negocio, que incluye operaciones y algoritmos espec\u00edficos para llevar a cabo las tareas requeridas.</p>"},{"location":"Desplegar/intro/#exposicion-de-un-servicio","title":"Exposici\u00f3n de un servicio","text":"<p>Normalmente, cuando se implementa un servidor o servicio en una red local o entorno interno, este se encuentra inaccesible directamente desde Internet debido a cuestiones de seguridad y configuraci\u00f3n de red. Sin embargo, en algunos casos, es necesario exponer un servicio para permitir su acceso desde redes externas. La exposici\u00f3n de un servicio implica realizar ajustes en la configuraci\u00f3n del servidor y de la red para habilitar el acceso desde fuera de la red local.</p>"},{"location":"Desplegar/intro/#configuracion-de-puertos","title":"Configuraci\u00f3n de puertos","text":"<p>La configuraci\u00f3n de puertos es un paso fundamental para exponer un servicio. Los servicios en un servidor se comunican a trav\u00e9s de puertos espec\u00edficos, que act\u00faan como puntos de entrada para las solicitudes entrantes. Al configurar un servidor para exponer un servicio, es necesario abrir los puertos correspondientes en el firewall y en la configuraci\u00f3n de red para permitir que las solicitudes externas lleguen al servidor. Esto implica especificar los puertos de escucha del servicio y asegurarse de que est\u00e9n abiertos y redirigidos correctamente hacia el servidor.</p>"},{"location":"Desplegar/intro/#port-forwarding-reenvio-de-puertos","title":"Port Forwarding (Reenv\u00edo de puertos)","text":"<p>En muchos casos, el servidor se encuentra detr\u00e1s de un enrutador o firewall que act\u00faa como punto de entrada a la red. Para que las solicitudes externas lleguen al servidor, se debe configurar el port forwarding (reenv\u00edo de puertos) en el enrutador o firewall. El port forwarding implica redirigir las solicitudes entrantes desde un puerto espec\u00edfico en el enrutador o firewall hacia un puerto correspondiente en el servidor interno. Esto garantiza que las solicitudes externas sean enrutadas correctamente al servicio deseado en el servidor.</p>"},{"location":"Desplegar/intro/#medidas-de-seguridad","title":"Medidas de seguridad","text":"<p>Es importante tener en cuenta que al exponer un servicio, tambi\u00e9n se deben considerar las medidas de seguridad necesarias para proteger el servidor y el servicio expuesto. Esto implica implementar medidas como autenticaci\u00f3n, cifrado de datos y configuraciones de seguridad adicionales para evitar accesos no autorizados y posibles vulnerabilidades.</p>"},{"location":"Desplegar/intro/#servidor-cttn","title":"Servidor CTTN","text":"<p>Dado todo lo explicado en el apartado anterior y contextualiz\u00e1ndose al servidor del CTTN, los servicios que se quieren exponer, se dividen en dos sectores:</p> <ul> <li>Privados: Aquellos servicios los cuales necesitas acceso como un administrador sin estar f\u00edsicamente en el servidor.</li> <li>P\u00fablicos: Aquellos servicios los cuales est\u00e1n expuestos para el p\u00fablico general y sean usados.</li> </ul> <p>Debido a que el servidor del CTTN utiliza la red de UTALCA, se ha configurado con su propia IP p\u00fablica, y solo se exponen los servicios HTTP (puerto 80) y HTTPS (puerto 443). Debido a esta configuraci\u00f3n, no es posible acceder a otros servicios, como SSH, que el servidor dispone fuera de la red de UTALCA. El puerto HTTP (Hypertext Transfer Protocol) y el puerto HTTPS (HTTP Secure) son puertos est\u00e1ndar utilizados para la comunicaci\u00f3n entre los clientes (navegadores web) y los servidores web.</p> <ol> <li>Puerto HTTP (puerto 80): El puerto 80 es el puerto predeterminado utilizado para las conexiones HTTP no seguras. HTTP es un protocolo de aplicaci\u00f3n utilizado para transferir datos y contenido web desde un servidor a un cliente, como un navegador web. El tr\u00e1fico HTTP no est\u00e1 encriptado, lo que significa que la informaci\u00f3n transmitida, incluyendo las solicitudes y respuestas, se env\u00eda en texto plano y puede ser interceptada y le\u00edda por terceros.</li> <li>Puerto HTTPS (puerto 443): El puerto 443 es el puerto predeterminado utilizado para las conexiones HTTPS seguras. HTTPS es una versi\u00f3n segura de HTTP que utiliza el protocolo SSL/TLS (Secure Sockets Layer/Transport Layer Security) para encriptar el tr\u00e1fico entre el cliente y el servidor. Esto proporciona una capa adicional de seguridad y privacidad, ya que los datos transmitidos est\u00e1n cifrados y no pueden ser f\u00e1cilmente interceptados o modificados por terceros.</li> </ol>"},{"location":"Desplegar/intro/#servicios-privados","title":"Servicios Privados","text":"<p>Para solucionar este problema, se utiliza Cloudflare Tunnel, una herramienta proporcionada por Cloudflare que permite exponer servicios en servidores internos o locales de manera segura a trav\u00e9s de la red de Cloudflare e Internet. Con Cloudflare Tunnel, se puede establecer una conexi\u00f3n segura y encriptada entre tu servidor interno y los servidores de Cloudflare en la nube, lo que permite exponer servicios de manera segura a trav\u00e9s de la red de Cloudflare.</p> <p>Cloudflare Tunnel utiliza un cliente llamado <code>cloudflared</code> que se ejecuta en tu servidor interno y establece una conexi\u00f3n segura saliente con los servidores de Cloudflare. Esta conexi\u00f3n segura se mantiene activa y se utiliza para enrutar el tr\u00e1fico entre Internet y tu servidor interno a trav\u00e9s de la red de Cloudflare.</p> <p>Una vez que la conexi\u00f3n se ha establecido, Cloudflare Tunnel asigna una URL \u00fanica al servicio, utilizando el subdominio de elecci\u00f3n en un dominio ya registrado. Esto permite acceder a al servicio a trav\u00e9s de esta URL asignada, y Cloudflare se encarga de enrutar el tr\u00e1fico entrante a trav\u00e9s de la conexi\u00f3n segura hacia el servidor interno.</p> <p>Cloudflare Tunnel es especialmente \u00fatil en escenarios donde se necesita exponer servicios internos de manera segura, como aplicaciones web, APIs, servidores de bases de datos, entre otros. Proporciona una forma conveniente y segura de acceder a estos servicios sin tener que exponer directamente tu red interna a Internet.</p> <p>Cloudflare Tunnel se est\u00e1 usando espec\u00edficamente para servicios importantes como SSH (Secure Shell). Es un protocolo de red que permite el acceso remoto y seguro a trav\u00e9s de una conexi\u00f3n cifrada. SSH proporciona una forma segura de autenticaci\u00f3n y comunicaci\u00f3n entre dispositivos, y se utiliza ampliamente en entornos de administraci\u00f3n de sistemas y redes.</p> <p>Al utilizar Cloudflare Tunnel para servicios cr\u00edticos como SSH, se puede aprovechar las caracter\u00edsticas de seguridad y rendimiento de la red global de Cloudflare, como lo puede ser doble autentificaci\u00f3n, adem\u00e1s de ocultar la direcci\u00f3n IP real de tus servidores internos y una configuraci\u00f3n r\u00e1pida y simple para el acceso remoto a a servicios importantes donde luego se pueden cerrar.</p> <p>En resumen, Cloudflare Tunnel es una soluci\u00f3n sencilla y segura para enrutar el tr\u00e1fico a trav\u00e9s de HTTPS, especialmente si est\u00e1s buscando una implementaci\u00f3n r\u00e1pida y no tienes necesidades de configuraci\u00f3n y personalizaci\u00f3n muy complejas.</p>"},{"location":"Desplegar/intro/#servicios-publicos","title":"Servicios P\u00fablicos","text":"<p>Por supuesto, aqu\u00ed tienes una versi\u00f3n reescrita del p\u00e1rrafo:</p> <p>Cuando se ejecuta un servicio localmente, este ocupa un puerto en la red local. Sin embargo, debido a la limitada disponibilidad de puertos comunes para exponer el servicio al p\u00fablico externo, se requiere un servicio de Proxy. Este servicio act\u00faa como intermediario monitorizando los puertos HTTP y HTTPS, redirigiendo el tr\u00e1fico hacia otros servicios y permitiendo as\u00ed la comunicaci\u00f3n externa.</p> <p>Con el fin de abordar esta necesidad, se ha decidido utilizar Nginx Proxy Manager.. Esta herramienta simplifica la configuraci\u00f3n y gesti\u00f3n de proxies inversos utilizando el servidor web Nginx. A trav\u00e9s de su interfaz gr\u00e1fica de usuario, se pueden establecer reglas para enrutamiento del tr\u00e1fico HTTP y HTTPS hacia los servicios correspondientes, facilitando la exposici\u00f3n de los servicios locales al exterior.</p> <p>En resumen, Nginx Proxy Manager. se utiliza como un servicio de Proxy que monitorea y redirige el tr\u00e1fico de los puertos HTTP y HTTPS hacia los servicios locales, permitiendo as\u00ed la comunicaci\u00f3n con el p\u00fablico externo. Su elecci\u00f3n se debe a la limitada disponibilidad de puertos comunes para exponer directamente los servicios al exterior.</p> <p>Si bien como se mencion\u00f3 en la secci\u00f3n anterior Cloudflare Tunnel ya realiza este proceso de una manera sencilla y r\u00e1pida junto con una conexi\u00f3n segura. Al utilizar un proxy inverso se puede tener un mayor control y flexibilidad sobre la configuraci\u00f3n, as\u00ed como un rendimiento directo y una menor latencia, ya que el tr\u00e1fico se enruta directamente desde el cliente al servidor.</p> <p>Esta combinaci\u00f3n de Cloudflare Tunnel y Nginx Proxy Manager permite aprovechar las fortalezas de cada soluci\u00f3n en funci\u00f3n de tus necesidades espec\u00edficas.</p> <p>Por otra parte Cloudflare Tunnel puede ser cerrado desde el servidor o directamente desde mi cuenta personal. Por lo que cuando ya no sea necesario que tenga acceso directo al servidor este puede ser eliminado.</p>"},{"location":"Desplegar/intro/#despliegue-de-smart-mesck","title":"Despliegue de Smart-Mesck","text":"<p>Para realizar la aplicaci\u00f3n de Smart-Mesck se dividi\u00f3 en m\u00e1s de una aplicaci\u00f3n. A continuaci\u00f3n, se explicar\u00e1 c\u00f3mo construir y ejecutar estas aplicaciones sin tener problemas debido a configuraciones o credenciales que puedan faltar.</p> <ul> <li>Smart-Mesck-UI: Esta es la interfaz gr\u00e1fica de la p\u00e1gina web, que se encarga de proporcionar una experiencia amigable para el usuario. La UI se comunica con la API para obtener los datos necesarios y mostrarlos al usuario de manera adecuada.</li> <li>Smart-Mesck-API: Esta es la aplicaci\u00f3n web API que se encarga de la mayor parte de la l\u00f3gica de la aplicaci\u00f3n. La API es responsable de procesar las solicitudes de la UI, comunicarse con la base de datos y proporcionar los datos solicitados a la UI.</li> <li>Smart-Mesck-Graph: Esta es una aplicaci\u00f3n web con el \u00fanico objetivo de poder graficar los datos.</li> </ul> <p>En conjunto, la UI y la API trabajan en conjunto para crear una aplicaci\u00f3n funcional y amigable para el usuario. La UI se encarga de la presentaci\u00f3n y la interacci\u00f3n con el usuario, mientras que la API maneja la l\u00f3gica y la comunicaci\u00f3n con la base de datos.</p> <p></p>"},{"location":"Desplegar/smart-mesck-server/","title":"Smart Mesck Server","text":"<p>A continuaci\u00f3n, se detallar\u00e1n los pasos necesarios para llevar a cabo la construcci\u00f3n y configuraci\u00f3n de Smart-Mesck-Server, as\u00ed como tambi\u00e9n se proporcionar\u00e1n los pasos para su despliegue. Sigue las instrucciones cuidadosamente para asegurarte de tener una implementaci\u00f3n exitosa del servidor y garantizar una experiencia \u00f3ptima para los usuarios.</p>"},{"location":"Desplegar/smart-mesck-server/#descargar-e-instalar-python","title":"Descargar e Instalar Python","text":"<ul> <li>Visita el sitio web oficial de Python.</li> <li>Haz clic en el bot\u00f3n de descarga correspondiente a tu sistema operativo (Windows, macOS o Linux).</li> <li>Sigue las instrucciones de instalaci\u00f3n proporcionadas por el instalador de Python.</li> <li>Verifica que Python se haya instalado correctamente abriendo una ventana de terminal y ejecutando el siguiente comando:</li> </ul> <pre><code>python --version\n</code></pre> <p>Deber\u00edas ver la versi\u00f3n instalada de Python.</p>"},{"location":"Desplegar/smart-mesck-server/#instalar-las-dependencias-del-proyecto","title":"Instalar las dependencias del proyecto","text":"<ul> <li>Abre una ventana de terminal.</li> <li>Navega hasta el directorio ra\u00edz de tu proyecto.</li> <li>Ejecuta el siguiente comando para instalar las dependencias del proyecto:</li> </ul> <pre><code>pip install -r requirements.txt\n</code></pre> <p>Esto descargar\u00e1 e instalar\u00e1 todas las dependencias listadas en el archivo <code>requirements.txt</code>. Por lo que es necesario tener una conexi\u00f3n a internet para poder realizar toda la descarga.</p>"},{"location":"Desplegar/smart-mesck-server/#configurar-las-variables-de-entorno","title":"Configurar las variables de entorno","text":"<p>Este proyecto requiere el uso de variables de entorno. Como primer paso, verifica que el fichero .env exista en el directorio ra\u00edz del proyecto y contenga la informaci\u00f3n necesaria. Por ejemplo:</p> <pre><code>SECRET_KEY = \"###\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\nDB_URL = \"postgresql://user:password@host/database\"\nMAIL_NAME=\"CTTN\"\nMAIL_USER=\"no-reply@cttn.cl\"\nMAIL_PASS=\"###\"\nMAIL_HOST=\"mail.cttn.cl\"\nMAIL_PORT=465\nBASE_URL = \"http://localhost:8000\"\nSMART_MESCK_URL = \"http://localhost:5173\"\nHAPI_FHIR_URL = \"https://castudillo-hapi.darknacho.xyz/fhir\"\n</code></pre> <ul> <li> <p><code>SECRET_KEY</code>: Esta variable almacena la clave secreta utilizada para validar los tokens JWT (JSON Web Tokens) en la aplicaci\u00f3n. Esta clave se utiliza para verificar la autenticidad y la integridad de los tokens, y es importante mantenerla en secreto para garantizar la seguridad del sistema.</p> </li> <li> <p><code>ALGORITHM</code>: Esta variable especifica el algoritmo de cifrado que se utilizar\u00e1 para generar y verificar tokens de acceso. En este caso, se utiliza el algoritmo HS256, que es un algoritmo de cifrado basado en una clave secreta.</p> </li> <li> <p><code>ACCESS_TOKEN_EXPIRE_MINUTES</code>: Esta variable define el tiempo de expiraci\u00f3n de los tokens de acceso generados por la aplicaci\u00f3n. En este caso, los tokens de acceso expirar\u00e1n despu\u00e9s de 30 minutos.</p> </li> <li> <p><code>DB_URL</code>: Esta variable almacena el connection string para la base de datos utilizada por la aplicaci\u00f3n. Aseg\u00farate de tener instalado un adaptador que soporte SQLAlchemy para tu base de datos espec\u00edfica. En este ejemplo, se utiliza una base de datos PostgreSQL y se proporciona el connection string, incluyendo el nombre de usuario, contrase\u00f1a, host y nombre de la base de datos.</p> </li> <li> <p><code>MAIL_NAME</code>, <code>MAIL_USER</code>, <code>MAIL_PASS</code>, <code>MAIL_HOST</code>, <code>MAIL_PORT</code>: Estas variables almacenan la informaci\u00f3n de configuraci\u00f3n del servidor de correo electr\u00f3nico utilizado por la aplicaci\u00f3n para enviar correos electr\u00f3nicos. Incluyen el nombre del remitente, la direcci\u00f3n de correo electr\u00f3nico del remitente, la contrase\u00f1a del remitente, el host del servidor de correo y el puerto utilizado para la conexi\u00f3n.</p> </li> </ul> <p><code>BASE_URL</code>: Esta variable almacena la URL base de la aplicaci\u00f3n. Es la URL principal a la que los usuarios acceder\u00e1n para interactuar con la aplicaci\u00f3n.</p> <p><code>SMART_MESCK_URL</code>: Esta variable almacena la URL del servicio Smart Mesck al que la aplicaci\u00f3n se conectar\u00e1. Es la direcci\u00f3n del servidor que proporciona funcionalidades espec\u00edficas para la aplicaci\u00f3n.</p> <p><code>HAPI_FHIR_URL</code>: Esta variable almacena la URL del servicio HAPI FHIR al que la aplicaci\u00f3n se conectar\u00e1. HAPI FHIR es una implementaci\u00f3n de la especificaci\u00f3n FHIR (Fast Healthcare Interoperability Resources) y se utiliza para el intercambio de datos de salud.</p> <p>Estas variables de entorno son configuradas en un archivo .env en el directorio ra\u00edz del proyecto y se utilizan en la aplicaci\u00f3n para acceder a la informaci\u00f3n necesaria para su funcionamiento.</p>"},{"location":"Desplegar/smart-mesck/","title":"Smart Mesck Web","text":"<p>A continuaci\u00f3n, se detallar\u00e1n los pasos necesarios para llevar a cabo la construcci\u00f3n y configuraci\u00f3n de Smart-Mesck-UI, as\u00ed como tambi\u00e9n se proporcionar\u00e1n los pasos para su despliegue. Sigue las instrucciones cuidadosamente para asegurarte de tener una implementaci\u00f3n exitosa de la interfaz gr\u00e1fica y garantizar una experiencia \u00f3ptima para los usuarios.</p>"},{"location":"Desplegar/smart-mesck/#descargar-e-instalar-nodejs","title":"Descargar e Instalar Node.js","text":"<ul> <li>Visita el sitio web oficial de Node.js.</li> <li>Haz clic en el bot\u00f3n de descarga correspondiente a tu sistema operativo (Windows, macOS o Linux).</li> <li>Sigue las instrucciones de instalaci\u00f3n proporcionadas por el instalador de Node.js.</li> <li>Verifica que Node.js se haya instalado correctamente abriendo una ventana de terminal y ejecutando el siguiente comando:</li> </ul> <pre><code>$ node --version\n</code></pre> <p>Deber\u00edas ver la versi\u00f3n instalada de Node.js.</p>"},{"location":"Desplegar/smart-mesck/#construir-la-aplicacion","title":"Construir la aplicaci\u00f3n","text":"<p>Abre una ventana de terminal. Navega hasta el directorio ra\u00edz de tu proyecto . Ejecuta el siguiente comando para instalar las dependencias del proyecto:</p> <pre><code>$ npm install\n</code></pre> <p>Esto descargar\u00e1 e instalar\u00e1 todas las dependencias listadas en el archivo <code>package.json</code>. Por lo que es necesario tener una conexi\u00f3n a internet para poder realizar toda la descarga.</p> <ul> <li>Una vez completada la instalaci\u00f3n de las dependencias, puedes ejecutar uno de los scripts definidos en el archivo <code>package.json</code>. Por ejemplo, para iniciar la aplicaci\u00f3n en modo de desarrollo, ejecuta:</li> </ul> <pre><code>$ npm run dev\n</code></pre> <p>Esto iniciar\u00e1 la aplicaci\u00f3n utilizando el comando <code>vite --mode development</code> proporcionado en el script <code>dev</code> del archivo <code>package.json</code>.</p> <ul> <li>Para construir la aplicaci\u00f3n, ejecuta:</li> </ul> <pre><code>$ npm run build\n</code></pre> <p>Esto generar\u00e1 los archivos optimizados listos para desplegar en un entorno de producci\u00f3n.</p>"},{"location":"Desplegar/smart-mesck/#ejecutar-el-proyecto","title":"Ejecutar el proyecto","text":"<ol> <li>Este proyecto, requiere el uso de variables de entorno, por lo que como primer paso es necesario</li> </ol> <p>Verificar que el fichero <code>.env</code> exista ubicada en <code>src</code> y contenga la siguiente informaci\u00f3n:</p> <pre><code>VITE_API_URL=https://castudillo-hapi.darknacho.xyz/fhir\nVITE_SERVER_URL=https://castudillo-chart-server-sm.darknacho.xyz\nVITE_CHART_SERVER_URL=wss://castudillo-chart-server-sm.darknacho.xyz/dashboard_ws\n</code></pre> <p>Estos argumentos representan los dominios donde se encuentran los servicios los cuales se utilizan.</p> <ol> <li>Despu\u00e9s de configurar las variables de entorno y haber completado la instalaci\u00f3n de las dependencias, ejecuta el siguiente comando para iniciar la aplicaci\u00f3n:</li> </ol> <pre><code>$ npm run dev\n    &gt; smart-mesck@0.0.0 dev\n    &gt; vite --mode development\n        VITE v5.2.10  ready in 3971 ms\n        \u279c  Local:   http://localhost:5173/\n        \u279c  Network: use --host to expose\n        \u279c  press h + enter to show help\n</code></pre> <p>Estos mensajes proporcionan informaci\u00f3n \u00fatil sobre la aplicaci\u00f3n en ejecuci\u00f3n:</p> <p>Este mensaje muestra que la aplicaci\u00f3n est\u00e1 escuchando en <code>http://localhost:5173</code>, lo cual indica que se ha configurado HTTP para la aplicaci\u00f3n.</p>"},{"location":"FHIR/fhir/","title":"Fast Healthcare Interoperability Resources","text":"<p>FHIR, es uno de esos est\u00e1ndares de interoperabilidad de datos que se utiliza y adopta ampliamente en la industria de la salud para compartir informaci\u00f3n relacionada con la atenci\u00f3n m\u00e9dica. FHIR sigue siendo muy prometedor para desarrollar un enfoque basado en aplicaciones para la interoperabilidad y el intercambio de informaci\u00f3n sanitaria.</p>"},{"location":"FHIR/fhir/#historia","title":"Historia","text":"<p>A principios de la d\u00e9cada de 2000, la tarea de almacenar y compartir datos era una tarea dif\u00edcil. Esto tambi\u00e9n era un caso real para la informaci\u00f3n relacionada a una atenci\u00f3n m\u00e9dica. Antes de FHIR, HL7v2 y HL7v3 era el est\u00e1ndar utilizado para la atenci\u00f3n m\u00e9dica. HL7v2 fue uno de los est\u00e1ndares iniciales desarrollados por HL7, pero su naturaleza de ser demasiado denso en informaci\u00f3n y complicado llev\u00f3 al desarrollo de un est\u00e1ndar m\u00e1s nuevo llamado HL7v3. Aunque HL7v3 supuso un gran esfuerzo y ten\u00eda muchas caracter\u00edsticas interesantes, nunca despeg\u00f3 porque no pod\u00eda mantenerse al d\u00eda con la tecnolog\u00eda de esa \u00e9poca. La tecnolog\u00eda b\u00e1sica fue una gran barrera para lograr cualquier tipo de interoperabilidad tanto en el caso de la v2 como de la v3. FHIR se cre\u00f3 como respuesta a estas antiguas tecnolog\u00edas para satisfacer las necesidades modernas de datos e interoperabilidad.</p>"},{"location":"FHIR/fhirclient/","title":"Comunicaci\u00f3n con FHIR Server","text":"<p>Para comunicarse con un servidor FHIR, es necesario tener un cliente FHIR dado a que este juega un papel importante cuando se trata de interacci\u00f3n con el servidor FHIR. En otras palabras, si un servidor FHIR es el habilitador para trabajar con las especificaciones FHIR, entonces un cliente FHIR es un habilitador para trabajar con servidores FHIR.</p> <p>Aunque la especificaci\u00f3n FHIR es completa en s\u00ed misma, ya que define los recursos, los tipos de datos, los perfiles, las solicitudes HTTP, etc. Por lo tanto, podemos trabajar e interactuar con los servidores FHIR directamente sin involucrar a los clientes FHIR. Pero, siendo realistas, ser\u00eda muy dif\u00edcil y quiz\u00e1 no sea la mejor opci\u00f3n. Necesitamos encargarnos de la interacci\u00f3n con el objeto FHIR, la validaci\u00f3n de objetos FHIR, la autorizaci\u00f3n de solicitudes HTTP y mucho m\u00e1s. Todas estas operaciones transversales son necesarias pero causan dificultades en el desarrollo real de las especificaciones FHIR. Ah\u00ed es donde los clientes de FHIR acuden a nuestro rescate.</p> <p></p> <p>El cliente FHIR se encuentra entre los servidores FHIR y la aplicaci\u00f3n como un habilitador para que los desarrolladores interact\u00faen f\u00e1cilmente con los servidores FHIR y se concentren en el desarrollo real. Los clientes FHIR no solo se limitan a la interacci\u00f3n con el servidor FHIR, sino que tambi\u00e9n brindan funciones como validaci\u00f3n, autorizaci\u00f3n, control de versiones, etc. Esto no solo facilita la vida del desarrollador mientras trabaja con FHIR, sino que tambi\u00e9n les ayuda a trabajar de manera eficiente y crear archivos m\u00e1s confiables. y aplicaciones FHIR estables. Adem\u00e1s, analizaremos las diferentes caracter\u00edsticas de los clientes FHIR.</p> <p></p>"},{"location":"FHIR/fhirclient/#conexion","title":"Conexi\u00f3n","text":"<p>Este es el primer paso para desarrollar cualquier aplicaci\u00f3n FHIR: conectarla al servidor FHIR. Esta funci\u00f3n consta de cuatro partes: EndPoint, Autenticaci\u00f3n, Encabezados y Versi\u00f3n. Esta conexi\u00f3n puede o no ser espec\u00edfica de una versi\u00f3n FHIR (STU2, STU3, R4). El cliente FHIR llevar\u00e1 un EndPoint al servidor FHIR que ayudar\u00e1 a interactuar f\u00e1cilmente con los servidores FHIR. Tambi\u00e9n est\u00e1n integrados diferentes m\u00e9todos (b\u00e1sico, token de portador, etc.) de autenticaci\u00f3n y los usuarios proporcionan entradas seg\u00fan los requisitos. Los clientes de FHIR tambi\u00e9n permiten al usuario elegir la versi\u00f3n de FHIR que desea utilizar.</p> <p></p>"},{"location":"FHIR/fhirclient/#metods-rest","title":"M\u00e9tods REST","text":"<p>Despu\u00e9s de crear la conexi\u00f3n y ahora es el momento para usar la conexi\u00f3n y realizar las operaci\u00f3n en el servidor FHIR. El cliente FHIR proporciona m\u00e9todos incorporados para realizar diferentes operaciones CRUD en el servidor FHIR. Los usuarios s\u00f3lo tendr\u00edan que llamar a los m\u00e9todos incorporados para realizar operaciones como crear, leer, actualizar y eliminar. El cliente crear\u00e1 internamente las API y las llamar\u00e1 cuando llamemos al m\u00e9todo de ejecuci\u00f3n.</p>"},{"location":"FHIR/fhirclient/#recursos","title":"Recursos","text":"<p>Esta es una de las caracter\u00edsticas m\u00e1s importantes de FHIR porque el conecctarse a un servidor y realizar consultas es un procedimiento normal, pero sin los modelos de os recursos, no se puede implementar un cliente FHIR. Para interactuar con los recursos de FHIR es importante tener los modelos respectivos con los cuales podemos interactuar f\u00e1cilmente con los recursos de FHIR en un entorno nativo en cualquier idioma. El modelo FHIR Resources est\u00e1 implementado de tal manera que podemos implementar f\u00e1cilmente funciones como referencias de recursos sin la molestia de encontrar soluciones alternativas. Los recursos tambi\u00e9n se encargan de la conformidad de los elementos y la validez de los valores a trav\u00e9s de enumeraciones definidas.</p> <p></p>"},{"location":"FHIR/fhirclient/#parsing-serializacion","title":"Parsing &amp; Serializaci\u00f3n","text":"<p>El an\u00e1lisis es un proceso de conversi\u00f3n de una cadena v\u00e1lida en un objeto FHIR y la serializaci\u00f3n es un proceso de conversi\u00f3n de un objeto FHIR en forma de cadena. Estas operaciones se vuelven muy pr\u00e1cticas y \u00fatiles cuando queremos realizar alguna implementaci\u00f3n multiplataforma con FHIR y donde es posible que FHIR no sea compatible de forma nativa. El valor predeterminado puede dar errores o puede no funcionar con los recursos FHIR en una biblioteca de cliente FHIR y puede dar el error, es por eso que cada cliente FHIR viene con el serializador y analizador incorporado para superar este problema.</p> <p></p> <p></p>"},{"location":"FHIR/fhirclient/#busqueda","title":"B\u00fasqueda","text":"<p>Esta es la operaci\u00f3n m\u00e1s importante y frecuente que puede realizar en un Servidor FHIR. No todas las organizaciones tienen su propio servidor FHIR ni necesitan tener uno, por lo que no necesitan realizar otras operaciones con tanta frecuencia como la operaci\u00f3n de b\u00fasqueda. Por ejemplo: supongamos que un hospital cumple totalmente con la especificaci\u00f3n FHIR en su trabajo y forma de almacenar los datos y tiene un sistema implementado para utilizar este sistema. Cuando un paciente viene al hospital para un chequeo, lo primero que har\u00e1 el hospital es conectar registros m\u00e9dicos comunes y buscar los registros del paciente. FHIR admite de forma nativa operaciones de b\u00fasqueda muy potentes. El cliente FHIR s\u00f3lo hace que estas operaciones de b\u00fasqueda sean m\u00e1s simples, r\u00e1pidas y eficientes.</p>"},{"location":"FHIR/fhirclient/#fhir-exchange-module","title":"FHIR Exchange Module","text":"<p>FHIR est\u00e1 dise\u00f1ado como una especificaci\u00f3n de interfaz: especifica el contenido de los datos intercambiados entre aplicaciones de atenci\u00f3n m\u00e9dica y c\u00f3mo se implementa y gestiona el intercambio. FHIR define los siguientes m\u00e9todos para intercambiar datos entre sistemas. Cada uno de los m\u00e9todos est\u00e1 destinado a un caso de uso espec\u00edfico y tiene ventajas y desventajas. El m\u00e9todo que se podr\u00eda utilizar depender\u00e1 del caso de uso.</p> <ol> <li> <p>API REST: la mayor\u00eda de las implementaciones se centran en aplicaciones API REST. Esta es una API cliente/servidor dise\u00f1ada para seguir los principios del dise\u00f1o REST para operaciones de creaci\u00f3n, lectura, actualizaci\u00f3n y eliminaci\u00f3n (CRUD), junto con soporte de b\u00fasqueda y ejecuci\u00f3n (operaciones).</p> </li> <li> <p>Mensajer\u00eda: admite el intercambio entre sistemas mediante el env\u00edo de mensajes enrutados de un sistema a otro. Este intercambio se puede implementar en la API REST o mediante alguna otra tecnolog\u00eda de mensajer\u00eda.</p> </li> <li> <p>Documentos: En este contenido a intercambiar est\u00e1 envuelto por una Composici\u00f3n que proporciona el contexto del contenido, y que tiene una presentaci\u00f3n fija para un lector humano. El marco del documento se proporciona para ayudar con los usos de comunicaci\u00f3n de persona a persona asistida por computadora, que no son infrecuentes en la atenci\u00f3n m\u00e9dica.</p> </li> <li> <p>Base de datos/Almac\u00e9n persistente: Otra forma de hacer uso de los recursos definidos por FHIR es almacenarlos de forma nativa en una base de datos o almac\u00e9n persistente, donde diferentes aplicaciones o m\u00f3dulos escriben y leen los recursos como parte de su implementaci\u00f3n.</p> </li> </ol> <p></p>"},{"location":"FHIR/fhirserver/","title":"Servidores FHIR","text":"<p>C\u00f3mo se sabe, FHIR es un est\u00e1ndar de interoperabilidad de datos para el intercambio de datos de atenci\u00f3n m\u00e9dica, pero FHIR en si solo un est\u00e1ndar y no nos permite desarrollar aplicaciones interoperables. Para utilizar FHIR en todo su potencial y utilizar aplicaciones de desarrollo de FHIR necesitar\u00edamos alg\u00fan habilitador que nos permita utilizar e interactuar con FHIR. Sin el habilitador, FHIR ser\u00eda como la documentaci\u00f3n de un lenguaje de programaci\u00f3n sin ninguna forma de implementar o utilizar ese lenguaje de programaci\u00f3n. FHIR Server es uno de esos facilitadores para FHIR.</p> <p></p> <p>Los servidores FHIR son herramientas clave para la interoperabilidad de los datos de salud. FHIR, como habilitador, proporciona diferentes funcionalidades para desarrollar aplicaciones utilizando FHIR. Diferentes servidores FHIR pueden proporcionarle diferentes funciones, pero la funcionalidad b\u00e1sica incluye:</p> <ol> <li> <p>Almacenamiento de datos: dado que FHIR proporciona modelos/recursos de datos personalizados, ser\u00eda una tarea muy dif\u00edcil implementar un almac\u00e9n de datos personalizado para almacenar objetos FHIR. Por este motivo, los servidores FHIR proporcionan la implementaci\u00f3n para el almacenamiento de datos FHIR. Diferentes servidores FHIR pueden proporcionar diferentes implementaciones para los almacenamientos de datos FHIR y pueden usar SQL o No-SQL para la implementaci\u00f3n subyacente.</p> </li> <li> <p>API Rest de FHIR: las especificaciones FHIR tambi\u00e9n definen la especificaci\u00f3n de las API Rest para la interacci\u00f3n con los recursos de FHIR. El servidor FHIR proporciona la implementaci\u00f3n de estas API Rest de FHIR y formas estandarizadas de interactuar con el almacenamiento de datos subyacente de FHIR.</p> </li> <li> <p>Validaci\u00f3n de perfil: otra caracter\u00edstica importante que proporciona la mayor\u00eda del servidor FHIR es la validaci\u00f3n de perfil para el recurso. El recurso FHIR en s\u00ed mismo es muy amplio y debemos limitar estos recursos a nuestras necesidades y esto se logra utilizando perfiles. El servidor FHIR proporciona funciones para la validaci\u00f3n de los recursos FHIR antes de agregarlos al almacenamiento de datos. De esta manera, podemos asegurarnos de que cada recurso FHIR se ajuste al perfil dado.</p> </li> <li> <p>UI para interacci\u00f3n: la mayor\u00eda de los servidores FHIR tambi\u00e9n vienen con una UI simple para una f\u00e1cil interacci\u00f3n de los recursos y API de FHIR. Esta interfaz de usuario proporciona una de las mejores formas de ejecutar e interactuar con las API y los recursos de FHIR y ver los cambios a medida que se realizan.</p> </li> </ol> <p>Existen diferentes servidores FHIR disponibles, tanto de c\u00f3digo abierto como de soluciones patentadas, para los principales proveedores de la nube.</p>"},{"location":"FHIR/fhirserver/#open-source","title":"Open Source","text":"<p>Estas son soluciones e implementaciones de uso gratuito de los servidores FHIR. Estas soluciones le proporcionar\u00e1n funciones b\u00e1sicas sobre las cuales podr\u00e1 desarrollar sus propias soluciones personalizadas. Estos se consideran buenos puntos de partida para desarrollar su propia aplicaci\u00f3n utilizando las especificaciones FHIR. A continuaci\u00f3n se muestran algunos ejemplos:</p> <ol> <li>HAPI FHIR</li> <li>LinuxForHealth FHIR</li> </ol>"},{"location":"FHIR/fhirserver/#pagadas","title":"Pagadas","text":"<p>A diferencia de las soluciones de c\u00f3digo abierto mencionadas anteriormente, estas no son de c\u00f3digo abierto ni de uso gratuito, pero a cambio le brindan mucha m\u00e1s funcionalidad que las soluciones de c\u00f3digo abierto, como la capacidad de realizar an\u00e1lisis en la tienda FHIR para generar predicciones futuras. Son \u00fatiles para desarrollar soluciones avanzadas que admitan las especificaciones FHIR. A continuaci\u00f3n se muestran algunos ejemplos:</p> <ol> <li>Google FHIR store</li> <li>Azure FHIR services</li> <li>AWS FHIR APIs</li> </ol>"},{"location":"FHIR/introduction/","title":"Introducci\u00f3n","text":"<p>En esta era de transformaci\u00f3n digital e innovaci\u00f3n, la recopilaci\u00f3n y el intercambio de datos se convierten en una de las tareas m\u00e1s importantes para las organizaciones. Si bien la recopilaci\u00f3n de datos es esencial, es igualmente importante la interoperabilidad y el intercambio de datos. Sin la interoperabilidad de los datos, estos permanecer\u00e1n aislados y no podr\u00e1n utilizarse en todo su potencial.</p>"},{"location":"FHIR/introduction/#que-es-la-interoperabilidad-de-datos","title":"\u00bfQu\u00e9 es la interoperabilidad de datos?","text":"<p>La interoperabilidad de datos es la propiedad que facilita el intercambio y el uso sin restricciones de datos o recursos entre sistemas dispares. Para que dos o m\u00e1s sistemas sean interoperables, deben poder intercambiar, interpretar y presentar datos compartidos de manera que el otro las entienda. Para establecer la interoperabilidad de los datos, es necesario establecer un conjunto de protocolos que deben seguir, tanto el remitente como el receptor de los datos. Diferentes industrias pueden seguir est\u00e1ndares comunes de interoperabilidad de datos que cumplen y cubren est\u00e1ndares y requisitos espec\u00edficos de la industria.</p>"},{"location":"FHIR/resources/","title":"Recursos FHIR","text":"<p>Los recursos son los componentes b\u00e1sicos del est\u00e1ndar FHIR. B\u00e1sicamente se recoge de la especificaci\u00f3n HTTP que b\u00e1sicamente define todo y los recursos direccionables. FHIR b\u00e1sicamente define un registro de salud como la recopilaci\u00f3n de recursos. por ejemplo, el Registro m\u00e9dico puede almacenar la informaci\u00f3n de la condici\u00f3n del paciente, en FHIR esto puede almacenarse como el recurso Condici\u00f3n y paciente. Cada recurso se puede representar en diferentes formas como XML y JSON. Algo que lo hace ideal para aplicaciones API REST.</p>"},{"location":"FHIR/resources/#data-modelsresources","title":"Data Models/Resources","text":"<p>Cada recurso en FHIR tiene una narrativa y un caso de uso por detr\u00e1s. Una narrativa en FHIR puede representar una situaci\u00f3n, algunos actores y otras entidades relacionadas con la salud. Para empezar, FHIR define una amplia variedad de recursos. Para saber m\u00e1s de estos, existe su documentaci\u00f3n proporcionada por HL7.</p> <p></p> <p>Los recursos m\u00e1s importantes para cada servicio cl\u00ednico podr\u00edan considerarse los siguientes:</p> <ol> <li> <p>Patient: Persona que recibe el servicio de atenci\u00f3n m\u00e9dica.</p> </li> <li> <p>Condition: Representa la condici\u00f3n de un paciente.</p> </li> <li> <p>Observations: Representa los informes diagn\u00f3sticos del paciente.</p> </li> <li> <p>Appointment: Representa la visita de un paciente a una cl\u00ednica.</p> </li> </ol> <p></p> <ol> <li> <p>Name: el nombre del elemento en el recurso.</p> </li> <li> <p>Flags: un conjunto de informaci\u00f3n sobre el elemento que afecta la forma en que los implementadores los manejan. por ejemplo: \\(\\sum\\) representa que el elemento est\u00e1 incluido en la b\u00fasqueda resumida.</p> </li> <li> <p>Cardinality: los l\u00edmites inferior y superior de cu\u00e1ntas veces se permite que este elemento aparezca en el recurso.</p> </li> <li> <p>Type: el tipo de datos del elemento. Estos pueden ser tipos simples como cadenas o tipos complejos como referencias a otros recursos.</p> </li> <li> <p>Description &amp; Constraints: una descripci\u00f3n del elemento y detalles sobre las restricciones que se le aplican.</p> </li> </ol> <p></p> <p>Cada recurso en FHIR puede constar de las siguientes partes:</p> <ol> <li> <p>Metadata: proporciona informaci\u00f3n adicional sobre el recurso, por ejemplo: ResourceId, versi\u00f3n del recurso, perfiles y etiquetas.</p> </li> <li> <p>Narrative: versi\u00f3n legible por humanos del contenido.</p> </li> <li> <p>Extensions: Esto se utiliza para implementar atributos que un recurso no contiene pero es necesario para la instituci\u00f3n cl\u00ednica.</p> </li> <li> <p>Elements/Body: Representa los recursos de contenido reales.</p> </li> </ol>"},{"location":"FHIR/resources/#fhir-profiles","title":"FHIR Profiles","text":"<p>Sabemos que el concepto b\u00e1sico de FHIR es que todo est\u00e1 representado como recursos. Estos recursos pueden ser muy amplios y un atributo en un recurso puede representarse de varias maneras.</p> <p>Entonces, para fomentar la interoperabilidad, es posible que deseemos limitar los recursos de acuerdo con nuestras propias especificaciones y limitaciones. Ah\u00ed es donde la creaci\u00f3n de perfiles entra en escena.</p> <p>En resumen, El perfil FHIR es una forma de limitar los recursos de FHIR para cumplir con ciertos est\u00e1ndares definidos. Es una especie de esquema de datos para el recurso FHIR.</p> <p>//TODO: Investigar m\u00e1s de este asunto en c\u00f3mo implementarlos. </p>"},{"location":"Smart-Mesck/arquitectura/","title":"Arquitectura L\u00f3gica","text":""},{"location":"Smart-Mesck/introduction/","title":"Introducci\u00f3n","text":""},{"location":"Smart-Mesck/introduction/#que-es-smart-mesck","title":"\u00bf Qu\u00e9 es Smart Mesck ?","text":""},{"location":"Smart-Mesck/seguridad/","title":"Seguridad","text":"<p>En t\u00e9rminos de seguridad, este sistema utiliza autentificaci\u00f3n basada en JWT, o JSON Web Tokens. Un JWT es una forma segura de representar reclamaciones que se pueden transferir entre dos partes. En el contexto de la autentificaci\u00f3n, despu\u00e9s de que un usuario inicia sesi\u00f3n con sus credenciales, el servidor crea un JWT que contiene informaci\u00f3n identificativa del usuario y lo env\u00eda de vuelta al usuario.</p> <p>Este token se incluye luego en el encabezado de cada solicitud que el usuario hace al servidor. Cuando el servidor recibe una solicitud, puede verificar el JWT para confirmar que el usuario es quien dice ser y proporcionar acceso a los recursos solicitados. Este m\u00e9todo de autentificaci\u00f3n es seguro y eficiente, y es ampliamente utilizado en aplicaciones web modernas.</p> <p>Un JWT se compone de tres partes: el encabezado, la carga \u00fatil y la firma. El encabezado y la carga \u00fatil o tambi\u00e9n conocido como payload contiene informaci\u00f3n conciderada importante, mientras que la firma se utiliza para verificar que el token no ha sido alterado en tr\u00e1nsito. Juntos, estos tres componentes proporcionan una forma robusta de autentificar a los usuarios y proteger los recursos del servidor.</p> <p>Por lo tanto, la seguridad de este sistema se basa en gran medida en la autentificaci\u00f3n basada en JWT para garantizar que solo los usuarios autenticados puedan acceder a ciertos recursos.</p> <p>El payload de un JWT es la parte del token que contiene las \"afirmaciones\" o declaraciones. En este caso, el payload contiene tres afirmaciones: id, role y exp.</p> <p>id: Esta afirmaci\u00f3n contiene el ID del usuario. Este es un identificador \u00fanico que se utiliza para identificar al usuario en la aplicaci\u00f3n. Por ejemplo, si el ID del usuario es \"1234\", el payload podr\u00eda verse as\u00ed: \"id\": \"1234\".</p> <p>role: Esta afirmaci\u00f3n contiene el rol del usuario. Este es un valor que indica qu\u00e9 permisos tiene el usuario en la aplicaci\u00f3n. Por ejemplo, si el usuario es un paciente, el payload podr\u00eda verse as\u00ed: \"role\": \"Patient\".</p> <p>exp: Esta afirmaci\u00f3n contiene la fecha de expiraci\u00f3n del token. Este es un valor num\u00e9rico que representa el n\u00famero de segundos desde la \u00e9poca de Unix (1970-01-01T00:00:00Z UTC) hasta la fecha/hora en que el token debe expirar. Por ejemplo, si el token debe expirar el 1 de enero de 2023 a las 00:00:00 UTC, el payload podr\u00eda verse as\u00ed: \"exp\": 1672444800.</p> <p>Por lo tanto, un ejemplo de un payload de JWT para este proyecto podr\u00eda ser:</p> <pre><code>{\n    \"id\": \"1234\",\n    \"role\": \"Patient\",\n    \"exp\": 1672444800\n}\n</code></pre> <p>Este payload indica que el token pertenece a un usuario con ID \"1234\", que el usuario es un paciente y que el token expira el 1 de enero de 2023 a las 00:00:00 UTC.</p>"},{"location":"Smart-Mesck/seguridad/#smart-mesck-web","title":"Smart Mesck Web","text":"<p>Dado que Smart Mesck Web funciona como el cliente FHIR Este se comunica primero con el m\u00f3dulo de autentificaci\u00f3n, utilizando las credenciales del usuario, este responder\u00e1 un JWT para ser usado en en HAPI FHIR.</p>"},{"location":"Smart-Mesck/seguridad/#autorizacion-en-hapi-fhir","title":"Autorizaci\u00f3n en HAPI FHIR","text":"<p>HAPI FHIR no cuenta con una forma de autentificaci\u00f3n integrada por lo que fue necesario agregar una para manejarlo junto a las reglas de acceso y visibilidad de recursos.</p> <p>Internamente funciona como un Interceptor, el cual intercepta todas las solicitudes al servicio para verificar que estos contengan la autentificaci\u00f3n correcta y decidir si puede acceder o no a lo que est\u00e1 solicitando.</p> <p></p>"},{"location":"Smart-Mesck/servicios/","title":"Servicios","text":""},{"location":"Smart-Mesck/servicios/#smart-mesck-web","title":"Smart Mesck Web","text":"<p>Smart Mesck Web es la interfaz de usuario de la plataforma. En t\u00e9rminos sencillos, es la p\u00e1gina web con la que interact\u00faas cuando usas el servicio. Es la cara de nuestro servicio, donde los usuarios y profesionales pueden interactuar de manera visual y amigable. Por \u00faltimo actua como el cliente FHIR para poder realizar todas las consultas necesarias.</p>"},{"location":"Smart-Mesck/servicios/#server-nombre-pendiente","title":"Server (nombre pendiente)","text":"<p>Este es el servicio el cual contiene l\u00f3gica de la aplicaci\u00f3n la cual es totalmente en el servidor. Este se utiliza para las siguientes funciones:</p> <ul> <li> <p>Auntentifiaci\u00f3n: Este servicio se encarga de registrar y autentificar los usuarios que utilizar\u00e1n el sistema.</p> </li> <li> <p>Graficar:  Esta servicio se encarga de crear representaciones visuales de los datos.</p> </li> </ul>"},{"location":"Smart-Mesck/servicios/#hapi-fhir","title":"HAPI FHIR","text":"<p>HAPI FHIR, producto de la empresa Smile CDR, es una implementaci\u00f3n de c\u00f3digo abierto de la especificaci\u00f3n HL7 FHIR para Java. Es una aplicaci\u00f3n que permite intercambiar datos cl\u00ednicos de una forma moderna y f\u00e1cil de ser implementada por los desarrolladores; esta aplicaci\u00f3n est\u00e1 dise\u00f1ada con una intenci\u00f3n principal: Proveer un modo flexible de a\u00f1adir caracter\u00edsticas FHIR al funcionamiento.</p> <p>HAPI FHIR proporciona una serie de mecanismos para implementar un servidor FHIR, en este caso se utiliza:</p> <ul> <li>JPA Server: El servidor HAPI FHIR JPA es una implementaci\u00f3n completa de FHIR contra una base de datos relacional; a diferencia del servidor simple, el servidor JPA proporciona su propio esquema de base de datos y gestiona toda la l\u00f3gica de almacenamiento y recuperaci\u00f3n sin necesidad de de codificaci\u00f3n.</li> </ul> <p></p>"},{"location":"Smart-Mesck/servicios/#autentificacion","title":"Autentificaci\u00f3n","text":"<p>Se a\u00f1adi\u00f3 manualmente al poryecto un m\u00f3dulo extra especificamente para manejar la autentificaci\u00f3n y permisos.</p>"}]}